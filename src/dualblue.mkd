# La dent bleue...

Avant de coder quoi que ce soit, petit historique du bluetooth (avec des vrais morceaux de [wikipedia](http://fr.wikipedia.org/wiki/Bluetooth) dedans).

Cette technologie à été mis au point par Ericsson en 1994, la première version de la spécification n'est sortie qu'en 1999.

D'après la wikipedia anglaise, le bluetooth serait né d'une volontée de portage de la norme RS232 vers une technologie sans-fil.

Pour faire court, il s'agit d'une spécification permettant la communication sans-fil entre différents appareils dans un champs relativement  restreint.
Trois classes d'appareils sont définies en fonction de leur portée et de leur puissance d'émission :

- Classe I : 100m max (100mW)
- Classe II : 10-20m (2.5mW)
- Classe III : moins de 10m (1mW)

D'après ce qu'on en sait, la majorité des fabricants se positionnent sur la classe 2.
Il y a de fortes chance que Lego ait fait de même.

Enfin (parce qu'on est super curieux) on est allés jeter un coup d'oeil aux topologies courantes.
Toujours d'après nos amis de l'encyclopédie libre bien connue, la topologie utilisée par NXt semble être de type __picoréseau__ (ou __piconet__).

A titre d'information, cette topologie semble nous permettre de diriger 7 esclaves actifs avec 1 maîtres ou 255 esclaves "rangés" (parked).

# NXT et Bluetooth

Là, ça devient velu.

La doc est pas claire, vraiment pas.
En fait, pour comprendre un minimum comment utiliser cette possibilité de la brique NXT, une recherche sur le web a été indispensable.

Après quelques secondes (c'est beau la technologie), nous sommes tombé sur une [page où l'auteur semblait avoir réussi à définir un protocole](http://www.alfonsomartone.itb.it/yepuji.html).

Après lecture du code tout entier (et c'est long), Mathieu s'est lancé dans la réécriture du protocole pour qu'il nous convienne.

Les données (code de commande + paramètres éventuels) sont encapsulés dans le cadre fourni par le langage NCX, et renvoyées sous forme de `string`.

L'envoi se fait de la manière suivante :

1. On construit le message soit directement dans une `string`, soit dans un tableau de `byte`
2. On vérifie l'état de la connexion maître-esclave
3. On utilise `BluetoothWrite()` pour recopier le buffer d'envoi sur la connexion
4. On vérifie la connexion pour savoir si ça a marché

Ce dernier point est interessant.
Avant même de regarder le web, nous pensions utiliser :

- deux octets d'entête
- un octet spécifiant la longueur
- un octet contenant une somme de contrôle
- deux octets d'EOT

Finalement, entête et EOT sont pris en charge par le NXC ainsi que la longueur.

La somme de contrôle nous semblait une perte de temps :
- la connexion n'est pas sensible
- le ratio utilité/temps de développement était trop faible

Finalement nous nous sommes rabatus sur un protocole simpliste et sans `handshaking`, il est conçu pour répondre à nos attentes, et seulement celles ci.

# Anatomie d'un message

Un message est constitué comme suit :

- 0x80 : on attent pas de réponse (on en aura une quand même, mais bon). 
- 0x09 : on envoie directement un code de commande
- MAILBOX : boite au lettre à utiliser
- longueur de la donnée
- donnée

## Anatomie de la donnée

La données est composé d'un code de commande (maître) suivi d'éventuels paramètres ou d'un simple code de réponse (esclave)

Codes de commandes :
- `BOT_ROTATE_MOTOR_EX 0xAE`
- `BOT_ON_FWD 0xF0`
- `BOT_OFF 0x00`
- `BOT_QUART_TOUR_D 0xC0`
- `BOT_QUART_TOUR_G 0xC1`
- `BOT_VIRAGE_D 0xB0`
- `BOT_VIRAGE_G 0xB1`
- `BOT_DEMI_TOUR 0xD1`
- `BOT_DECALAGE 0xDE`

Les 6 derniers provoquent l'exécution de fonctions usuelles prédéfinies pour plus de commodité.

Codes de réponse :
- `SLAVE_ALL_IS_OK 0x42`
- `SLAVE_NOTHING_TO_DO 0xD0`
- `SLAVE_BUMPER 0xBB`
- `SLAVE_C_LA_DECH 0xCD`
